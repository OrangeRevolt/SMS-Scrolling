                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler 
                                      3 ; Version 4.3.2 #14359 (MINGW64)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mz80
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl ___SMS__SDSC_signature
                                     12 	.globl ___SMS__SDSC_descr
                                     13 	.globl ___SMS__SDSC_name
                                     14 	.globl ___SMS__SDSC_author
                                     15 	.globl ___SMS__SEGA_signature
                                     16 	.globl _main
                                     17 	.globl _cam_pan_down
                                     18 	.globl _cam_pan_up
                                     19 	.globl _cam_pan_left
                                     20 	.globl _cam_pan_right
                                     21 	.globl _redraw_stage
                                     22 	.globl _init_camera
                                     23 	.globl _SMS_VRAMmemsetW
                                     24 	.globl _SMS_VRAMmemcpy
                                     25 	.globl _SMS_getKeysHeld
                                     26 	.globl _SMS_configureTextRenderer
                                     27 	.globl _SMS_zeroSpritePalette
                                     28 	.globl _SMS_zeroBGPalette
                                     29 	.globl _SMS_loadSpritePalette
                                     30 	.globl _SMS_loadBGPalette
                                     31 	.globl _SMS_copySpritestoSAT
                                     32 	.globl _SMS_initSprites
                                     33 	.globl _SMS_loadPSGaidencompressedTilesatAddr
                                     34 	.globl _SMS_waitForVBlank
                                     35 	.globl _SMS_setBackdropColor
                                     36 	.globl _SMS_setBGScrollY
                                     37 	.globl _SMS_setBGScrollX
                                     38 	.globl _SMS_VDPturnOffFeature
                                     39 	.globl _SMS_VDPturnOnFeature
                                     40 	.globl _camera
                                     41 	.globl _SMS_SRAM
                                     42 	.globl _SRAM_bank_to_be_mapped_on_slot2
                                     43 	.globl _ROM_bank_to_be_mapped_on_slot0
                                     44 	.globl _ROM_bank_to_be_mapped_on_slot1
                                     45 	.globl _ROM_bank_to_be_mapped_on_slot2
                                     46 ;--------------------------------------------------------
                                     47 ; special function registers
                                     48 ;--------------------------------------------------------
                           0000BF    49 _SMS_VDPControlPort	=	0x00bf
                                     50 ;--------------------------------------------------------
                                     51 ; ram data
                                     52 ;--------------------------------------------------------
                                     53 	.area _DATA
                           00FFFF    54 _ROM_bank_to_be_mapped_on_slot2	=	0xffff
                           00FFFE    55 _ROM_bank_to_be_mapped_on_slot1	=	0xfffe
                           00FFFD    56 _ROM_bank_to_be_mapped_on_slot0	=	0xfffd
                           00FFFC    57 _SRAM_bank_to_be_mapped_on_slot2	=	0xfffc
                           008000    58 _SMS_SRAM	=	0x8000
      000000                         59 _camera::
      000000                         60 	.ds 10
                                     61 ;--------------------------------------------------------
                                     62 ; ram data
                                     63 ;--------------------------------------------------------
                                     64 	.area _INITIALIZED
                                     65 ;--------------------------------------------------------
                                     66 ; absolute external ram data
                                     67 ;--------------------------------------------------------
                                     68 	.area _DABS (ABS)
                                     69 ;--------------------------------------------------------
                                     70 ; global & static initialisations
                                     71 ;--------------------------------------------------------
                                     72 	.area _HOME
                                     73 	.area _GSINIT
                                     74 	.area _GSFINAL
                                     75 	.area _GSINIT
                                     76 ;--------------------------------------------------------
                                     77 ; Home
                                     78 ;--------------------------------------------------------
                                     79 	.area _HOME
                                     80 	.area _HOME
                                     81 ;--------------------------------------------------------
                                     82 ; code
                                     83 ;--------------------------------------------------------
                                     84 	.area _CODE
                                     85 ;main.c:43: void init_camera(void)
                                     86 ;	---------------------------------
                                     87 ; Function init_camera
                                     88 ; ---------------------------------
      000000                         89 _init_camera::
                                     90 ;main.c:45: camera.view_x = CAM_START_X; //We can set it to a max of 128, which is at the width end of the tilemap.
      000000 21 00 00         [10]   91 	ld	hl, #0x0000
      000003 22r00r00         [16]   92 	ld	(_camera), hl
                                     93 ;main.c:46: camera.view_y = CAM_START_Y; //We can set it to a max of 24, which is at the height end of the tilemap.
      000006 22r02r00         [16]   94 	ld	((_camera + 2)), hl
                                     95 ;main.c:47: camera.scroll_x = 0;
      000009 01r04r00         [10]   96 	ld	bc, #_camera + 4
      00000C AF               [ 4]   97 	xor	a, a
      00000D 02               [ 7]   98 	ld	(bc), a
                                     99 ;main.c:48: camera.scroll_y = 0;
      00000E 21r05r00         [10]  100 	ld	hl, #(_camera + 5)
      000011 36 00            [10]  101 	ld	(hl), #0x00
                                    102 ;main.c:49: camera.coloffset = 0;
      000013 21 00 00         [10]  103 	ld	hl, #0x0000
      000016 22r06r00         [16]  104 	ld	((_camera + 6)), hl
                                    105 ;main.c:50: camera.rowoffset = 0;
      000019 22r08r00         [16]  106 	ld	((_camera + 8)), hl
                                    107 ;main.c:51: SMS_setBGScrollX(camera.scroll_x);
      00001C 0A               [ 7]  108 	ld	a, (bc)
      00001D 6F               [ 4]  109 	ld	l, a
                                    110 ;	spillPairReg hl
                                    111 ;	spillPairReg hl
      00001E CDr00r00         [17]  112 	call	_SMS_setBGScrollX
                                    113 ;main.c:52: SMS_setBGScrollY(camera.scroll_y);
      000021 21r05r00         [10]  114 	ld	hl, #(_camera + 5)
      000024 6E               [ 7]  115 	ld	l, (hl)
                                    116 ;	spillPairReg hl
                                    117 ;main.c:53: }
      000025 C3r00r00         [10]  118 	jp	_SMS_setBGScrollY
                                    119 ;main.c:54: void redraw_stage(void)
                                    120 ;	---------------------------------
                                    121 ; Function redraw_stage
                                    122 ; ---------------------------------
      000028                        123 _redraw_stage::
                                    124 ;main.c:56: SMS_mapROMBank(brawl_street_tilemap_bin_bank);
      000028 21 FF FF         [10]  125 	ld	hl, #_ROM_bank_to_be_mapped_on_slot2
      00002B 36 03            [10]  126 	ld	(hl), #0x03
                                    127 ;main.c:57: for(unsigned int y = 0; y < 28; y++) //load the fight stage.
      00002D 01 00 00         [10]  128 	ld	bc, #0x0000
      000030                        129 00103$:
      000030 79               [ 4]  130 	ld	a, c
      000031 D6 1C            [ 7]  131 	sub	a, #0x1c
      000033 78               [ 4]  132 	ld	a, b
      000034 DE 00            [ 7]  133 	sbc	a, #0x00
      000036 D0               [11]  134 	ret	NC
                                    135 ;main.c:59: SMS_loadTileMap(0,y,brawl_street_tilemap_bin + camera.view_x + (((y + camera.view_y) * 96) * 2), 64); //96 * 2 == the tilemap width in tiles (3 screens.)
      000037 ED 5Br00r00      [20]  136 	ld	de, (#_camera + 0)
      00003B 21r00r00         [10]  137 	ld	hl, #_brawl_street_tilemap_bin
      00003E 19               [11]  138 	add	hl, de
      00003F EB               [ 4]  139 	ex	de, hl
      000040 2Ar02r00         [16]  140 	ld	hl, (#(_camera + 2) + 0)
      000043 09               [11]  141 	add	hl, bc
      000044 D5               [11]  142 	push	de
      000045 5D               [ 4]  143 	ld	e, l
      000046 54               [ 4]  144 	ld	d, h
      000047 29               [11]  145 	add	hl, hl
      000048 19               [11]  146 	add	hl, de
      000049 29               [11]  147 	add	hl, hl
      00004A 29               [11]  148 	add	hl, hl
      00004B 29               [11]  149 	add	hl, hl
      00004C 29               [11]  150 	add	hl, hl
      00004D 29               [11]  151 	add	hl, hl
      00004E 29               [11]  152 	add	hl, hl
      00004F D1               [10]  153 	pop	de
      000050 19               [11]  154 	add	hl, de
      000051 EB               [ 4]  155 	ex	de, hl
      000052 69               [ 4]  156 	ld	l, c
      000053 60               [ 4]  157 	ld	h, b
      000054 29               [11]  158 	add	hl, hl
      000055 29               [11]  159 	add	hl, hl
      000056 29               [11]  160 	add	hl, hl
      000057 29               [11]  161 	add	hl, hl
      000058 29               [11]  162 	add	hl, hl
      000059 29               [11]  163 	add	hl, hl
      00005A 7C               [ 4]  164 	ld	a, h
      00005B F6 78            [ 7]  165 	or	a, #0x78
      00005D 67               [ 4]  166 	ld	h, a
                                    167 ;	spillPairReg hl
                                    168 ;	spillPairReg hl
      00005E C5               [11]  169 	push	bc
      00005F 01 40 00         [10]  170 	ld	bc, #0x0040
      000062 C5               [11]  171 	push	bc
      000063 CDr00r00         [17]  172 	call	_SMS_VRAMmemcpy
      000066 C1               [10]  173 	pop	bc
                                    174 ;main.c:57: for(unsigned int y = 0; y < 28; y++) //load the fight stage.
      000067 03               [ 6]  175 	inc	bc
                                    176 ;main.c:62: }
      000068 18 C6            [12]  177 	jr	00103$
                                    178 ;main.c:64: void cam_pan_right(void) 
                                    179 ;	---------------------------------
                                    180 ; Function cam_pan_right
                                    181 ; ---------------------------------
      00006A                        182 _cam_pan_right::
      00006A DD E5            [15]  183 	push	ix
      00006C DD 21 00 00      [14]  184 	ld	ix,#0
      000070 DD 39            [15]  185 	add	ix,sp
      000072 21 FA FF         [10]  186 	ld	hl, #-6
      000075 39               [11]  187 	add	hl, sp
      000076 F9               [ 6]  188 	ld	sp, hl
                                    189 ;main.c:67: if (camera.scroll_x % 8 == 0 && camera.view_x < 128) //When scroll_x remainder is zero, it's time to place tiles. Also don't draw tiles when at map end.
      000077 3Ar04r00         [13]  190 	ld	a, (#(_camera + 4) + 0)
      00007A E6 07            [ 7]  191 	and	a, #0x07
                                    192 ;main.c:74: for (unsigned char y = 0; y < 28; y++)
                                    193 ;main.c:67: if (camera.scroll_x % 8 == 0 && camera.view_x < 128) //When scroll_x remainder is zero, it's time to place tiles. Also don't draw tiles when at map end.
      00007C F6 00            [ 7]  194 	or	a,#0x00
      00007E C2r59r01         [10]  195 	jp	NZ, 00106$
      000081 2Ar00r00         [16]  196 	ld	hl, (#_camera + 0)
      000084 11 80 00         [10]  197 	ld	de, #0x0080
      000087 BF               [ 4]  198 	cp	a, a
      000088 ED 52            [15]  199 	sbc	hl, de
      00008A D2r59r01         [10]  200 	jp	NC, 00106$
                                    201 ;main.c:69: camera.rowoffset = (camera.scroll_y / 8);
      00008D 3Ar05r00         [13]  202 	ld	a, (#_camera + 5)
      000090 4F               [ 4]  203 	ld	c, a
      000091 06 00            [ 7]  204 	ld	b, #0x00
      000093 CB 28            [ 8]  205 	sra	b
      000095 CB 19            [ 8]  206 	rr	c
      000097 CB 28            [ 8]  207 	sra	b
      000099 CB 19            [ 8]  208 	rr	c
      00009B CB 28            [ 8]  209 	sra	b
      00009D CB 19            [ 8]  210 	rr	c
      00009F ED 43r08r00      [20]  211 	ld	((_camera + 8)), bc
                                    212 ;main.c:71: unsigned char rowoffset = camera.rowoffset; //Save the last state of rowoffset in a temp variable.
                                    213 ;main.c:72: unsigned char ydex = 0; //We store the current y loop position, in order to subtract from the loop, to start at zero again when at last tile position.
      0000A3 DD 36 FA 00      [19]  214 	ld	-6 (ix), #0x00
                                    215 ;main.c:74: for (unsigned char y = 0; y < 28; y++)
      0000A7 DD 36 FF 00      [19]  216 	ld	-1 (ix), #0x00
      0000AB                        217 00115$:
                                    218 ;main.c:67: if (camera.scroll_x % 8 == 0 && camera.view_x < 128) //When scroll_x remainder is zero, it's time to place tiles. Also don't draw tiles when at map end.
      0000AB 21r00r00         [10]  219 	ld	hl, #_camera
      0000AE 7E               [ 7]  220 	ld	a, (hl)
      0000AF DD 77 FB         [19]  221 	ld	-5 (ix), a
      0000B2 23               [ 6]  222 	inc	hl
      0000B3 7E               [ 7]  223 	ld	a, (hl)
      0000B4 DD 77 FC         [19]  224 	ld	-4 (ix), a
                                    225 ;main.c:74: for (unsigned char y = 0; y < 28; y++)
      0000B7 DD 7E FF         [19]  226 	ld	a, -1 (ix)
      0000BA D6 1C            [ 7]  227 	sub	a, #0x1c
      0000BC D2r4Dr01         [10]  228 	jp	NC, 00104$
                                    229 ;main.c:76: if (y >= 28 - rowoffset && rowoffset != 0)//When screen is offset, as the loop reaches the edge of the screen, we need to reset the loop so it begins at zero to finish off tiling.
      0000BF 59               [ 4]  230 	ld	e, c
      0000C0 16 00            [ 7]  231 	ld	d, #0x00
      0000C2 21 1C 00         [10]  232 	ld	hl, #0x001c
      0000C5 BF               [ 4]  233 	cp	a, a
      0000C6 ED 52            [15]  234 	sbc	hl, de
      0000C8 DD 7E FF         [19]  235 	ld	a, -1 (ix)
      0000CB DD 77 FD         [19]  236 	ld	-3 (ix), a
      0000CE DD 36 FE 00      [19]  237 	ld	-2 (ix), #0x00
      0000D2 DD 7E FD         [19]  238 	ld	a, -3 (ix)
      0000D5 95               [ 4]  239 	sub	a, l
      0000D6 DD 7E FE         [19]  240 	ld	a, -2 (ix)
      0000D9 9C               [ 4]  241 	sbc	a, h
      0000DA E2rDFr00         [10]  242 	jp	PO, 00189$
      0000DD EE 80            [ 7]  243 	xor	a, #0x80
      0000DF                        244 00189$:
      0000DF FArEEr00         [10]  245 	jp	M, 00102$
      0000E2 79               [ 4]  246 	ld	a, c
      0000E3 B7               [ 4]  247 	or	a, a
      0000E4 28 08            [12]  248 	jr	Z, 00102$
                                    249 ;main.c:78: rowoffset = 0; //removes the offset from the equation. we need to start at zero.
      0000E6 0E 00            [ 7]  250 	ld	c, #0x00
                                    251 ;main.c:79: ydex = y; //store the y loop current index, to subtract it.
      0000E8 DD 7E FF         [19]  252 	ld	a, -1 (ix)
      0000EB DD 77 FA         [19]  253 	ld	-6 (ix), a
      0000EE                        254 00102$:
                                    255 ;main.c:81: SMS_loadTileMap(camera.coloffset,rowoffset + (y - ydex),brawl_street_tilemap_bin + (camera.view_x + 64) + (((y + camera.view_y) * 96) * 2),2);
      0000EE DD 6E FB         [19]  256 	ld	l, -5 (ix)
                                    257 ;	spillPairReg hl
                                    258 ;	spillPairReg hl
      0000F1 DD 66 FC         [19]  259 	ld	h, -4 (ix)
                                    260 ;	spillPairReg hl
                                    261 ;	spillPairReg hl
      0000F4 11 40 00         [10]  262 	ld	de, #0x0040
      0000F7 19               [11]  263 	add	hl, de
      0000F8 FD 21r00r00      [14]  264 	ld	iy, #_brawl_street_tilemap_bin
      0000FC EB               [ 4]  265 	ex	de, hl
      0000FD FD 19            [15]  266 	add	iy, de
      0000FF 2Ar02r00         [16]  267 	ld	hl, (#_camera + 2)
      000102 DD 5E FD         [19]  268 	ld	e, -3 (ix)
      000105 DD 56 FE         [19]  269 	ld	d, -2 (ix)
      000108 19               [11]  270 	add	hl, de
      000109 5D               [ 4]  271 	ld	e, l
      00010A 54               [ 4]  272 	ld	d, h
      00010B 29               [11]  273 	add	hl, hl
      00010C 19               [11]  274 	add	hl, de
      00010D 29               [11]  275 	add	hl, hl
      00010E 29               [11]  276 	add	hl, hl
      00010F 29               [11]  277 	add	hl, hl
      000110 29               [11]  278 	add	hl, hl
      000111 29               [11]  279 	add	hl, hl
      000112 29               [11]  280 	add	hl, hl
      000113 EB               [ 4]  281 	ex	de, hl
      000114 FD 19            [15]  282 	add	iy, de
      000116 59               [ 4]  283 	ld	e, c
      000117 16 00            [ 7]  284 	ld	d, #0x00
      000119 DD 6E FA         [19]  285 	ld	l, -6 (ix)
                                    286 ;	spillPairReg hl
                                    287 ;	spillPairReg hl
      00011C 06 00            [ 7]  288 	ld	b, #0x00
      00011E DD 7E FD         [19]  289 	ld	a, -3 (ix)
      000121 95               [ 4]  290 	sub	a, l
      000122 6F               [ 4]  291 	ld	l, a
                                    292 ;	spillPairReg hl
                                    293 ;	spillPairReg hl
      000123 DD 7E FE         [19]  294 	ld	a, -2 (ix)
      000126 98               [ 4]  295 	sbc	a, b
      000127 67               [ 4]  296 	ld	h, a
                                    297 ;	spillPairReg hl
                                    298 ;	spillPairReg hl
      000128 19               [11]  299 	add	hl, de
      000129 29               [11]  300 	add	hl, hl
      00012A 29               [11]  301 	add	hl, hl
      00012B 29               [11]  302 	add	hl, hl
      00012C 29               [11]  303 	add	hl, hl
      00012D 29               [11]  304 	add	hl, hl
      00012E EB               [ 4]  305 	ex	de,hl
      00012F 3Ar06r00         [13]  306 	ld	a, (#(_camera + 6) + 0)
      000132 26 00            [ 7]  307 	ld	h, #0x00
                                    308 ;	spillPairReg hl
                                    309 ;	spillPairReg hl
      000134 6F               [ 4]  310 	ld	l, a
                                    311 ;	spillPairReg hl
                                    312 ;	spillPairReg hl
      000135 19               [11]  313 	add	hl, de
      000136 29               [11]  314 	add	hl, hl
      000137 7C               [ 4]  315 	ld	a, h
      000138 F6 78            [ 7]  316 	or	a, #0x78
      00013A 67               [ 4]  317 	ld	h, a
                                    318 ;	spillPairReg hl
                                    319 ;	spillPairReg hl
      00013B C5               [11]  320 	push	bc
      00013C 11 02 00         [10]  321 	ld	de, #0x0002
      00013F D5               [11]  322 	push	de
      000140 FD E5            [15]  323 	push	iy
      000142 D1               [10]  324 	pop	de
      000143 CDr00r00         [17]  325 	call	_SMS_VRAMmemcpy
      000146 C1               [10]  326 	pop	bc
                                    327 ;main.c:74: for (unsigned char y = 0; y < 28; y++)
      000147 DD 34 FF         [23]  328 	inc	-1 (ix)
      00014A C3rABr00         [10]  329 	jp	00115$
      00014D                        330 00104$:
                                    331 ;main.c:84: camera.view_x+= 2;
      00014D DD 4E FB         [19]  332 	ld	c, -5 (ix)
      000150 DD 46 FC         [19]  333 	ld	b, -4 (ix)
      000153 03               [ 6]  334 	inc	bc
      000154 03               [ 6]  335 	inc	bc
      000155 ED 43r00r00      [20]  336 	ld	(_camera), bc
      000159                        337 00106$:
                                    338 ;main.c:67: if (camera.scroll_x % 8 == 0 && camera.view_x < 128) //When scroll_x remainder is zero, it's time to place tiles. Also don't draw tiles when at map end.
      000159 2Ar00r00         [16]  339 	ld	hl, (#_camera + 0)
                                    340 ;main.c:86: if (camera.view_x < 128 || camera.view_x >= 128 && camera.scroll_x % 32 != 0)
      00015C 11 80 00         [10]  341 	ld	de, #0x0080
      00015F BF               [ 4]  342 	cp	a, a
      000160 ED 52            [15]  343 	sbc	hl, de
      000162 3E 00            [ 7]  344 	ld	a, #0x00
      000164 17               [ 4]  345 	rla
      000165 B7               [ 4]  346 	or	a, a
      000166 20 0C            [12]  347 	jr	NZ, 00108$
      000168 4F               [ 4]  348 	ld	c, a
      000169 CB 41            [ 8]  349 	bit	0, c
      00016B 20 28            [12]  350 	jr	NZ, 00109$
      00016D 3Ar04r00         [13]  351 	ld	a, (#(_camera + 4) + 0)
      000170 E6 1F            [ 7]  352 	and	a, #0x1f
      000172 28 21            [12]  353 	jr	Z, 00109$
      000174                        354 00108$:
                                    355 ;main.c:88: camera.scroll_x--;
      000174 3Ar04r00         [13]  356 	ld	a, (#(_camera + 4) + 0)
      000177 3D               [ 4]  357 	dec	a
      000178 32r04r00         [13]  358 	ld	(#(_camera + 4)),a
                                    359 ;main.c:89: camera.coloffset = 32 - (camera.scroll_x / 8); //Get the position of the x scroll register in tiles.
      00017B 4F               [ 4]  360 	ld	c, a
      00017C 06 00            [ 7]  361 	ld	b, #0x00
      00017E CB 28            [ 8]  362 	sra	b
      000180 CB 19            [ 8]  363 	rr	c
      000182 CB 28            [ 8]  364 	sra	b
      000184 CB 19            [ 8]  365 	rr	c
      000186 CB 28            [ 8]  366 	sra	b
      000188 CB 19            [ 8]  367 	rr	c
      00018A 3E 20            [ 7]  368 	ld	a, #0x20
      00018C 91               [ 4]  369 	sub	a, c
      00018D 4F               [ 4]  370 	ld	c, a
      00018E 9F               [ 4]  371 	sbc	a, a
      00018F 90               [ 4]  372 	sub	a, b
      000190 47               [ 4]  373 	ld	b, a
      000191 ED 43r06r00      [20]  374 	ld	((_camera + 6)), bc
      000195                        375 00109$:
                                    376 ;main.c:93: if (camera.coloffset == 32)
      000195 2Ar06r00         [16]  377 	ld	hl, (#(_camera + 6) + 0)
      000198 7D               [ 4]  378 	ld	a, l
      000199 D6 20            [ 7]  379 	sub	a, #0x20
      00019B B4               [ 4]  380 	or	a, h
      00019C 20 06            [12]  381 	jr	NZ, 00117$
                                    382 ;main.c:95: camera.coloffset = 0;
      00019E 21 00 00         [10]  383 	ld	hl, #0x0000
      0001A1 22r06r00         [16]  384 	ld	((_camera + 6)), hl
      0001A4                        385 00117$:
                                    386 ;main.c:98: }
      0001A4 DD F9            [10]  387 	ld	sp, ix
      0001A6 DD E1            [14]  388 	pop	ix
      0001A8 C9               [10]  389 	ret
                                    390 ;main.c:100: void cam_pan_left(void)
                                    391 ;	---------------------------------
                                    392 ; Function cam_pan_left
                                    393 ; ---------------------------------
      0001A9                        394 _cam_pan_left::
      0001A9 DD E5            [15]  395 	push	ix
      0001AB DD 21 00 00      [14]  396 	ld	ix,#0
      0001AF DD 39            [15]  397 	add	ix,sp
      0001B1 21 FA FF         [10]  398 	ld	hl, #-6
      0001B4 39               [11]  399 	add	hl, sp
      0001B5 F9               [ 6]  400 	ld	sp, hl
                                    401 ;main.c:102: if (camera.view_x > 0)
      0001B6 2Ar00r00         [16]  402 	ld	hl, (#_camera + 0)
      0001B9 7C               [ 4]  403 	ld	a, h
      0001BA B5               [ 4]  404 	or	a, l
      0001BB 28 06            [12]  405 	jr	Z, 00102$
                                    406 ;main.c:104: camera.scroll_x++;
      0001BD 01r04r00         [10]  407 	ld	bc, #_camera+4
      0001C0 0A               [ 7]  408 	ld	a, (bc)
      0001C1 3C               [ 4]  409 	inc	a
      0001C2 02               [ 7]  410 	ld	(bc), a
      0001C3                        411 00102$:
                                    412 ;main.c:107: camera.coloffset = 32 - (camera.scroll_x / 8); //Get the position of the x scroll register in tiles.
      0001C3 01r04r00         [10]  413 	ld	bc, #_camera + 4
      0001C6 0A               [ 7]  414 	ld	a, (bc)
      0001C7 5F               [ 4]  415 	ld	e, a
      0001C8 16 00            [ 7]  416 	ld	d, #0x00
      0001CA CB 2A            [ 8]  417 	sra	d
      0001CC CB 1B            [ 8]  418 	rr	e
      0001CE CB 2A            [ 8]  419 	sra	d
      0001D0 CB 1B            [ 8]  420 	rr	e
      0001D2 CB 2A            [ 8]  421 	sra	d
      0001D4 CB 1B            [ 8]  422 	rr	e
      0001D6 21 20 00         [10]  423 	ld	hl, #0x0020
      0001D9 BF               [ 4]  424 	cp	a, a
      0001DA ED 52            [15]  425 	sbc	hl, de
      0001DC EB               [ 4]  426 	ex	de, hl
      0001DD ED 53r06r00      [20]  427 	ld	((_camera + 6)), de
                                    428 ;main.c:108: if (camera.coloffset == 32)
      0001E1 7B               [ 4]  429 	ld	a, e
      0001E2 D6 20            [ 7]  430 	sub	a, #0x20
      0001E4 B2               [ 4]  431 	or	a, d
      0001E5 20 06            [12]  432 	jr	NZ, 00104$
                                    433 ;main.c:110: camera.coloffset = 0;
      0001E7 21 00 00         [10]  434 	ld	hl, #0x0000
      0001EA 22r06r00         [16]  435 	ld	((_camera + 6)), hl
      0001ED                        436 00104$:
                                    437 ;main.c:113: if (camera.scroll_x % 8 == 0 && camera.view_x > 0)
      0001ED 0A               [ 7]  438 	ld	a, (bc)
      0001EE E6 07            [ 7]  439 	and	a, #0x07
      0001F0 C2rC5r02         [10]  440 	jp	NZ,00115$
      0001F3 2Ar00r00         [16]  441 	ld	hl, (#_camera + 0)
      0001F6 7C               [ 4]  442 	ld	a, h
      0001F7 B5               [ 4]  443 	or	a, l
      0001F8 CArC5r02         [10]  444 	jp	Z, 00115$
                                    445 ;main.c:115: camera.rowoffset = (camera.scroll_y / 8);
      0001FB 3Ar05r00         [13]  446 	ld	a, (#_camera + 5)
      0001FE 4F               [ 4]  447 	ld	c, a
      0001FF 06 00            [ 7]  448 	ld	b, #0x00
      000201 CB 28            [ 8]  449 	sra	b
      000203 CB 19            [ 8]  450 	rr	c
      000205 CB 28            [ 8]  451 	sra	b
      000207 CB 19            [ 8]  452 	rr	c
      000209 CB 28            [ 8]  453 	sra	b
      00020B CB 19            [ 8]  454 	rr	c
      00020D ED 43r08r00      [20]  455 	ld	((_camera + 8)), bc
                                    456 ;main.c:118: unsigned char rowoffset = camera.rowoffset; //Save the last state of rowoffset in a temp variable.
                                    457 ;main.c:119: unsigned char ydex = 0; //We store the current y loop position, in order to subtract from the loop, to start at zero again when at last tile position.
      000211 DD 36 FA 00      [19]  458 	ld	-6 (ix), #0x00
                                    459 ;main.c:120: for (unsigned char y = 0; y < 28; y++)
      000215 DD 36 FF 00      [19]  460 	ld	-1 (ix), #0x00
      000219                        461 00113$:
                                    462 ;main.c:113: if (camera.scroll_x % 8 == 0 && camera.view_x > 0)
      000219 2Ar00r00         [16]  463 	ld	hl, (#_camera + 0)
                                    464 ;main.c:127: SMS_loadTileMap(camera.coloffset,rowoffset + (y - ydex),brawl_street_tilemap_bin + (camera.view_x - 2) + (((y + camera.view_y) * 96) * 2),2);            
      00021C 7D               [ 4]  465 	ld	a, l
      00021D C6 FE            [ 7]  466 	add	a, #0xfe
      00021F DD 77 FB         [19]  467 	ld	-5 (ix), a
      000222 7C               [ 4]  468 	ld	a, h
      000223 CE FF            [ 7]  469 	adc	a, #0xff
      000225 DD 77 FC         [19]  470 	ld	-4 (ix), a
                                    471 ;main.c:120: for (unsigned char y = 0; y < 28; y++)
      000228 DD 7E FF         [19]  472 	ld	a, -1 (ix)
      00022B D6 1C            [ 7]  473 	sub	a, #0x1c
      00022D D2rB9r02         [10]  474 	jp	NC, 00108$
                                    475 ;main.c:122: if (y >= 28 - rowoffset && rowoffset != 0)//When screen is offset, as the loop reaches the edge of the screen, we need to reset the loop so it begins at zero to finish off tiling.
      000230 59               [ 4]  476 	ld	e, c
      000231 16 00            [ 7]  477 	ld	d, #0x00
      000233 21 1C 00         [10]  478 	ld	hl, #0x001c
      000236 BF               [ 4]  479 	cp	a, a
      000237 ED 52            [15]  480 	sbc	hl, de
      000239 DD 7E FF         [19]  481 	ld	a, -1 (ix)
      00023C DD 77 FD         [19]  482 	ld	-3 (ix), a
      00023F DD 36 FE 00      [19]  483 	ld	-2 (ix), #0x00
      000243 DD 7E FD         [19]  484 	ld	a, -3 (ix)
      000246 95               [ 4]  485 	sub	a, l
      000247 DD 7E FE         [19]  486 	ld	a, -2 (ix)
      00024A 9C               [ 4]  487 	sbc	a, h
      00024B E2r50r02         [10]  488 	jp	PO, 00184$
      00024E EE 80            [ 7]  489 	xor	a, #0x80
      000250                        490 00184$:
      000250 FAr5Fr02         [10]  491 	jp	M, 00106$
      000253 79               [ 4]  492 	ld	a, c
      000254 B7               [ 4]  493 	or	a, a
      000255 28 08            [12]  494 	jr	Z, 00106$
                                    495 ;main.c:124: rowoffset = 0; //removes the offset from the equation. we need to start at zero.
      000257 0E 00            [ 7]  496 	ld	c, #0x00
                                    497 ;main.c:125: ydex = y; //store the y loop current index, to subtract it.
      000259 DD 7E FF         [19]  498 	ld	a, -1 (ix)
      00025C DD 77 FA         [19]  499 	ld	-6 (ix), a
      00025F                        500 00106$:
                                    501 ;main.c:127: SMS_loadTileMap(camera.coloffset,rowoffset + (y - ydex),brawl_street_tilemap_bin + (camera.view_x - 2) + (((y + camera.view_y) * 96) * 2),2);            
      00025F FD 21r00r00      [14]  502 	ld	iy, #_brawl_street_tilemap_bin
      000263 DD 5E FB         [19]  503 	ld	e, -5 (ix)
      000266 DD 56 FC         [19]  504 	ld	d, -4 (ix)
      000269 FD 19            [15]  505 	add	iy, de
      00026B 2Ar02r00         [16]  506 	ld	hl, (#_camera + 2)
      00026E DD 5E FD         [19]  507 	ld	e, -3 (ix)
      000271 DD 56 FE         [19]  508 	ld	d, -2 (ix)
      000274 19               [11]  509 	add	hl, de
      000275 5D               [ 4]  510 	ld	e, l
      000276 54               [ 4]  511 	ld	d, h
      000277 29               [11]  512 	add	hl, hl
      000278 19               [11]  513 	add	hl, de
      000279 29               [11]  514 	add	hl, hl
      00027A 29               [11]  515 	add	hl, hl
      00027B 29               [11]  516 	add	hl, hl
      00027C 29               [11]  517 	add	hl, hl
      00027D 29               [11]  518 	add	hl, hl
      00027E 29               [11]  519 	add	hl, hl
      00027F EB               [ 4]  520 	ex	de, hl
      000280 FD 19            [15]  521 	add	iy, de
      000282 59               [ 4]  522 	ld	e, c
      000283 16 00            [ 7]  523 	ld	d, #0x00
      000285 DD 6E FA         [19]  524 	ld	l, -6 (ix)
                                    525 ;	spillPairReg hl
                                    526 ;	spillPairReg hl
      000288 06 00            [ 7]  527 	ld	b, #0x00
      00028A DD 7E FD         [19]  528 	ld	a, -3 (ix)
      00028D 95               [ 4]  529 	sub	a, l
      00028E 6F               [ 4]  530 	ld	l, a
                                    531 ;	spillPairReg hl
                                    532 ;	spillPairReg hl
      00028F DD 7E FE         [19]  533 	ld	a, -2 (ix)
      000292 98               [ 4]  534 	sbc	a, b
      000293 67               [ 4]  535 	ld	h, a
                                    536 ;	spillPairReg hl
                                    537 ;	spillPairReg hl
      000294 19               [11]  538 	add	hl, de
      000295 29               [11]  539 	add	hl, hl
      000296 29               [11]  540 	add	hl, hl
      000297 29               [11]  541 	add	hl, hl
      000298 29               [11]  542 	add	hl, hl
      000299 29               [11]  543 	add	hl, hl
      00029A EB               [ 4]  544 	ex	de,hl
      00029B 3Ar06r00         [13]  545 	ld	a, (#(_camera + 6) + 0)
      00029E 26 00            [ 7]  546 	ld	h, #0x00
                                    547 ;	spillPairReg hl
                                    548 ;	spillPairReg hl
      0002A0 6F               [ 4]  549 	ld	l, a
                                    550 ;	spillPairReg hl
                                    551 ;	spillPairReg hl
      0002A1 19               [11]  552 	add	hl, de
      0002A2 29               [11]  553 	add	hl, hl
      0002A3 7C               [ 4]  554 	ld	a, h
      0002A4 F6 78            [ 7]  555 	or	a, #0x78
      0002A6 67               [ 4]  556 	ld	h, a
                                    557 ;	spillPairReg hl
                                    558 ;	spillPairReg hl
      0002A7 C5               [11]  559 	push	bc
      0002A8 11 02 00         [10]  560 	ld	de, #0x0002
      0002AB D5               [11]  561 	push	de
      0002AC FD E5            [15]  562 	push	iy
      0002AE D1               [10]  563 	pop	de
      0002AF CDr00r00         [17]  564 	call	_SMS_VRAMmemcpy
      0002B2 C1               [10]  565 	pop	bc
                                    566 ;main.c:120: for (unsigned char y = 0; y < 28; y++)
      0002B3 DD 34 FF         [23]  567 	inc	-1 (ix)
      0002B6 C3r19r02         [10]  568 	jp	00113$
      0002B9                        569 00108$:
                                    570 ;main.c:130: camera.view_x-= 2;
      0002B9 21r00r00         [10]  571 	ld	hl, #_camera
      0002BC DD 7E FB         [19]  572 	ld	a, -5 (ix)
      0002BF 77               [ 7]  573 	ld	(hl), a
      0002C0 23               [ 6]  574 	inc	hl
      0002C1 DD 7E FC         [19]  575 	ld	a, -4 (ix)
      0002C4 77               [ 7]  576 	ld	(hl), a
      0002C5                        577 00115$:
                                    578 ;main.c:133: }
      0002C5 DD F9            [10]  579 	ld	sp, ix
      0002C7 DD E1            [14]  580 	pop	ix
      0002C9 C9               [10]  581 	ret
                                    582 ;main.c:135: void cam_pan_up(void)
                                    583 ;	---------------------------------
                                    584 ; Function cam_pan_up
                                    585 ; ---------------------------------
      0002CA                        586 _cam_pan_up::
      0002CA DD E5            [15]  587 	push	ix
      0002CC DD 21 00 00      [14]  588 	ld	ix,#0
      0002D0 DD 39            [15]  589 	add	ix,sp
      0002D2 F5               [11]  590 	push	af
      0002D3 F5               [11]  591 	push	af
                                    592 ;main.c:137: camera.rowoffset = 28 - (camera.scroll_y/8); //Get the position of the y scroll register.
      0002D4 3Ar05r00         [13]  593 	ld	a, (#(_camera + 5) + 0)
      0002D7 4F               [ 4]  594 	ld	c, a
      0002D8 06 00            [ 7]  595 	ld	b, #0x00
      0002DA CB 28            [ 8]  596 	sra	b
      0002DC CB 19            [ 8]  597 	rr	c
      0002DE CB 28            [ 8]  598 	sra	b
      0002E0 CB 19            [ 8]  599 	rr	c
      0002E2 CB 28            [ 8]  600 	sra	b
      0002E4 CB 19            [ 8]  601 	rr	c
      0002E6 3E 1C            [ 7]  602 	ld	a, #0x1c
      0002E8 91               [ 4]  603 	sub	a, c
      0002E9 4F               [ 4]  604 	ld	c, a
      0002EA 9F               [ 4]  605 	sbc	a, a
      0002EB 90               [ 4]  606 	sub	a, b
      0002EC 47               [ 4]  607 	ld	b, a
      0002ED ED 43r08r00      [20]  608 	ld	((_camera + 8)), bc
                                    609 ;main.c:139: if (camera.rowoffset == 28) //Tile placement is from 0-27. So when it hits 28 we need to reset the rowoffset.
      0002F1 79               [ 4]  610 	ld	a, c
      0002F2 D6 1C            [ 7]  611 	sub	a, #0x1c
      0002F4 B0               [ 4]  612 	or	a, b
      0002F5 20 06            [12]  613 	jr	NZ, 00102$
                                    614 ;main.c:141: camera.rowoffset = 0;
      0002F7 21 00 00         [10]  615 	ld	hl, #0x0000
      0002FA 22r08r00         [16]  616 	ld	((_camera + 8)), hl
      0002FD                        617 00102$:
                                    618 ;main.c:145: if (camera.scroll_y % 8 == 0 && camera.view_y > 0)
      0002FD 3Ar05r00         [13]  619 	ld	a, (#(_camera + 5) + 0)
      000300 4F               [ 4]  620 	ld	c, a
      000301 06 00            [ 7]  621 	ld	b, #0x00
      000303 79               [ 4]  622 	ld	a, c
      000304 E6 07            [ 7]  623 	and	a, #0x07
      000306 5F               [ 4]  624 	ld	e, a
      000307 16 00            [ 7]  625 	ld	d, #0x00
      000309 7A               [ 4]  626 	ld	a, d
      00030A B3               [ 4]  627 	or	a, e
      00030B C2rCCr03         [10]  628 	jp	NZ, 00108$
      00030E 2Ar02r00         [16]  629 	ld	hl, (#(_camera + 2) + 0)
      000311 AF               [ 4]  630 	xor	a, a
      000312 BD               [ 4]  631 	cp	a, l
      000313 9C               [ 4]  632 	sbc	a, h
      000314 E2r19r03         [10]  633 	jp	PO, 00192$
      000317 EE 80            [ 7]  634 	xor	a, #0x80
      000319                        635 00192$:
      000319 F2rCCr03         [10]  636 	jp	P, 00108$
                                    637 ;main.c:147: camera.rowoffset = (camera.scroll_y / 8);
      00031C CB 28            [ 8]  638 	sra	b
      00031E CB 19            [ 8]  639 	rr	c
      000320 CB 28            [ 8]  640 	sra	b
      000322 CB 19            [ 8]  641 	rr	c
      000324 CB 28            [ 8]  642 	sra	b
      000326 CB 19            [ 8]  643 	rr	c
      000328 ED 43r08r00      [20]  644 	ld	((_camera + 8)), bc
                                    645 ;main.c:149: unsigned char coloffset = camera.coloffset; //Save the last state of coloffset in a temp variable.
      00032C 21r06r00         [10]  646 	ld	hl, #_camera + 6
      00032F 4E               [ 7]  647 	ld	c, (hl)
                                    648 ;main.c:150: unsigned char xdex = 0; //We store the current x loop position, in order to subtract from the loop, to start at zero again when at last tile position.
      000330 DD 36 FC 00      [19]  649 	ld	-4 (ix), #0x00
                                    650 ;main.c:152: for (unsigned char x = 0; x < 32; x++)
      000334 DD 36 FF 00      [19]  651 	ld	-1 (ix), #0x00
      000338                        652 00116$:
                                    653 ;main.c:159: SMS_loadTileMap(coloffset + (x - xdex),camera.rowoffset - 1,brawl_street_tilemap_bin + (camera.view_x + (x * 2)) + (((camera.view_y - 1) * 96) * 2),2);         
      000338 2Ar02r00         [16]  654 	ld	hl, (#(_camera + 2) + 0)
      00033B 7D               [ 4]  655 	ld	a, l
      00033C C6 FF            [ 7]  656 	add	a, #0xff
      00033E DD 77 FD         [19]  657 	ld	-3 (ix), a
      000341 7C               [ 4]  658 	ld	a, h
      000342 CE FF            [ 7]  659 	adc	a, #0xff
      000344 DD 77 FE         [19]  660 	ld	-2 (ix), a
                                    661 ;main.c:152: for (unsigned char x = 0; x < 32; x++)
      000347 DD 7E FF         [19]  662 	ld	a, -1 (ix)
      00034A D6 20            [ 7]  663 	sub	a, #0x20
      00034C 30 72            [12]  664 	jr	NC, 00106$
                                    665 ;main.c:154: if (x >= 32 - coloffset && coloffset != 0)//When screen is offset, as the loop reaches the edge of the screen, we need to reset the loop so it begins at zero to finish off tiling.
      00034E 59               [ 4]  666 	ld	e, c
      00034F 16 00            [ 7]  667 	ld	d, #0x00
      000351 21 20 00         [10]  668 	ld	hl, #0x0020
      000354 BF               [ 4]  669 	cp	a, a
      000355 ED 52            [15]  670 	sbc	hl, de
      000357 DD 5E FF         [19]  671 	ld	e, -1 (ix)
      00035A 16 00            [ 7]  672 	ld	d, #0x00
      00035C 7B               [ 4]  673 	ld	a, e
      00035D 95               [ 4]  674 	sub	a, l
      00035E 7A               [ 4]  675 	ld	a, d
      00035F 9C               [ 4]  676 	sbc	a, h
      000360 E2r65r03         [10]  677 	jp	PO, 00193$
      000363 EE 80            [ 7]  678 	xor	a, #0x80
      000365                        679 00193$:
      000365 FAr74r03         [10]  680 	jp	M, 00104$
      000368 79               [ 4]  681 	ld	a, c
      000369 B7               [ 4]  682 	or	a, a
      00036A 28 08            [12]  683 	jr	Z, 00104$
                                    684 ;main.c:156: coloffset = 0; //removes the offset from the equation. we need to start at zero.
      00036C 0E 00            [ 7]  685 	ld	c, #0x00
                                    686 ;main.c:157: xdex = x; //store the x loop current index, to subtract it.
      00036E DD 7E FF         [19]  687 	ld	a, -1 (ix)
      000371 DD 77 FC         [19]  688 	ld	-4 (ix), a
      000374                        689 00104$:
                                    690 ;main.c:159: SMS_loadTileMap(coloffset + (x - xdex),camera.rowoffset - 1,brawl_street_tilemap_bin + (camera.view_x + (x * 2)) + (((camera.view_y - 1) * 96) * 2),2);         
      000374 2Ar00r00         [16]  691 	ld	hl, (#_camera + 0)
      000377 EB               [ 4]  692 	ex	de, hl
      000378 29               [11]  693 	add	hl, hl
      000379 EB               [ 4]  694 	ex	de, hl
      00037A 19               [11]  695 	add	hl, de
      00037B EB               [ 4]  696 	ex	de, hl
      00037C FD 21r00r00      [14]  697 	ld	iy, #_brawl_street_tilemap_bin
      000380 FD 19            [15]  698 	add	iy, de
      000382 DD 5E FD         [19]  699 	ld	e, -3 (ix)
      000385 DD 56 FE         [19]  700 	ld	d, -2 (ix)
      000388 6B               [ 4]  701 	ld	l, e
      000389 62               [ 4]  702 	ld	h, d
      00038A 29               [11]  703 	add	hl, hl
      00038B 19               [11]  704 	add	hl, de
      00038C 29               [11]  705 	add	hl, hl
      00038D 29               [11]  706 	add	hl, hl
      00038E 29               [11]  707 	add	hl, hl
      00038F 29               [11]  708 	add	hl, hl
      000390 29               [11]  709 	add	hl, hl
      000391 29               [11]  710 	add	hl, hl
      000392 EB               [ 4]  711 	ex	de, hl
      000393 FD 19            [15]  712 	add	iy, de
      000395 2Ar08r00         [16]  713 	ld	hl, (#(_camera + 8) + 0)
      000398 2B               [ 6]  714 	dec	hl
      000399 29               [11]  715 	add	hl, hl
      00039A 29               [11]  716 	add	hl, hl
      00039B 29               [11]  717 	add	hl, hl
      00039C 29               [11]  718 	add	hl, hl
      00039D 29               [11]  719 	add	hl, hl
      00039E DD 7E FF         [19]  720 	ld	a, -1 (ix)
      0003A1 DD 96 FC         [19]  721 	sub	a, -4 (ix)
      0003A4 81               [ 4]  722 	add	a, c
      0003A5 16 00            [ 7]  723 	ld	d, #0x00
      0003A7 5F               [ 4]  724 	ld	e, a
      0003A8 19               [11]  725 	add	hl, de
      0003A9 29               [11]  726 	add	hl, hl
      0003AA 7C               [ 4]  727 	ld	a, h
      0003AB F6 78            [ 7]  728 	or	a, #0x78
      0003AD 67               [ 4]  729 	ld	h, a
                                    730 ;	spillPairReg hl
                                    731 ;	spillPairReg hl
      0003AE C5               [11]  732 	push	bc
      0003AF 11 02 00         [10]  733 	ld	de, #0x0002
      0003B2 D5               [11]  734 	push	de
      0003B3 FD E5            [15]  735 	push	iy
      0003B5 D1               [10]  736 	pop	de
      0003B6 CDr00r00         [17]  737 	call	_SMS_VRAMmemcpy
      0003B9 C1               [10]  738 	pop	bc
                                    739 ;main.c:152: for (unsigned char x = 0; x < 32; x++)
      0003BA DD 34 FF         [23]  740 	inc	-1 (ix)
      0003BD C3r38r03         [10]  741 	jp	00116$
      0003C0                        742 00106$:
                                    743 ;main.c:162: camera.view_y--;
      0003C0 21r02r00         [10]  744 	ld	hl, #(_camera + 2)
      0003C3 DD 7E FD         [19]  745 	ld	a, -3 (ix)
      0003C6 77               [ 7]  746 	ld	(hl), a
      0003C7 23               [ 6]  747 	inc	hl
      0003C8 DD 7E FE         [19]  748 	ld	a, -2 (ix)
      0003CB 77               [ 7]  749 	ld	(hl), a
      0003CC                        750 00108$:
                                    751 ;main.c:165: if (camera.view_y > 0 || camera.scroll_y % 32 != 0)
      0003CC ED 4Br02r00      [20]  752 	ld	bc, (#(_camera + 2) + 0)
                                    753 ;main.c:137: camera.rowoffset = 28 - (camera.scroll_y/8); //Get the position of the y scroll register.
      0003D0 21r05r00         [10]  754 	ld	hl, #(_camera + 5)
      0003D3 5E               [ 7]  755 	ld	e, (hl)
                                    756 ;main.c:165: if (camera.view_y > 0 || camera.scroll_y % 32 != 0)
      0003D4 AF               [ 4]  757 	xor	a, a
      0003D5 B9               [ 4]  758 	cp	a, c
      0003D6 98               [ 4]  759 	sbc	a, b
      0003D7 E2rDCr03         [10]  760 	jp	PO, 00194$
      0003DA EE 80            [ 7]  761 	xor	a, #0x80
      0003DC                        762 00194$:
      0003DC FArE4r03         [10]  763 	jp	M, 00112$
      0003DF 7B               [ 4]  764 	ld	a, e
      0003E0 E6 1F            [ 7]  765 	and	a, #0x1f
      0003E2 28 0C            [12]  766 	jr	Z, 00118$
      0003E4                        767 00112$:
                                    768 ;main.c:168: camera.scroll_y--;
      0003E4 1D               [ 4]  769 	dec	e
      0003E5 21r05r00         [10]  770 	ld	hl, #(_camera + 5)
      0003E8 73               [ 7]  771 	ld	(hl), e
                                    772 ;main.c:169: if (camera.scroll_y > 223)
      0003E9 3E DF            [ 7]  773 	ld	a, #0xdf
      0003EB 93               [ 4]  774 	sub	a, e
      0003EC 30 02            [12]  775 	jr	NC, 00118$
                                    776 ;main.c:171: camera.scroll_y = 223;
      0003EE 36 DF            [10]  777 	ld	(hl), #0xdf
      0003F0                        778 00118$:
                                    779 ;main.c:175: }
      0003F0 DD F9            [10]  780 	ld	sp, ix
      0003F2 DD E1            [14]  781 	pop	ix
      0003F4 C9               [10]  782 	ret
                                    783 ;main.c:177: void cam_pan_down(void)
                                    784 ;	---------------------------------
                                    785 ; Function cam_pan_down
                                    786 ; ---------------------------------
      0003F5                        787 _cam_pan_down::
      0003F5 DD E5            [15]  788 	push	ix
      0003F7 DD 21 00 00      [14]  789 	ld	ix,#0
      0003FB DD 39            [15]  790 	add	ix,sp
      0003FD F5               [11]  791 	push	af
      0003FE F5               [11]  792 	push	af
                                    793 ;main.c:180: camera.rowoffset = 28 - (camera.scroll_y/8); //Get the position of the y scroll register in tiles.
      0003FF 01r05r00         [10]  794 	ld	bc, #_camera + 5
      000402 0A               [ 7]  795 	ld	a, (bc)
      000403 5F               [ 4]  796 	ld	e, a
      000404 16 00            [ 7]  797 	ld	d, #0x00
      000406 CB 2A            [ 8]  798 	sra	d
      000408 CB 1B            [ 8]  799 	rr	e
      00040A CB 2A            [ 8]  800 	sra	d
      00040C CB 1B            [ 8]  801 	rr	e
      00040E CB 2A            [ 8]  802 	sra	d
      000410 CB 1B            [ 8]  803 	rr	e
      000412 21 1C 00         [10]  804 	ld	hl, #0x001c
      000415 BF               [ 4]  805 	cp	a, a
      000416 ED 52            [15]  806 	sbc	hl, de
      000418 EB               [ 4]  807 	ex	de, hl
      000419 ED 53r08r00      [20]  808 	ld	((_camera + 8)), de
                                    809 ;main.c:182: if (camera.view_y < 24) //Prvent the scrolling from going past the height of the map. 24 tiles = 192 pixels
      00041D 2Ar02r00         [16]  810 	ld	hl, (#(_camera + 2) + 0)
      000420 11 18 80         [10]  811 	ld	de, #0x8018
      000423 29               [11]  812 	add	hl, hl
      000424 3F               [ 4]  813 	ccf
      000425 CB 1C            [ 8]  814 	rr	h
      000427 CB 1D            [ 8]  815 	rr	l
      000429 ED 52            [15]  816 	sbc	hl, de
      00042B 30 03            [12]  817 	jr	NC, 00102$
                                    818 ;main.c:184: camera.scroll_y++;
      00042D 0A               [ 7]  819 	ld	a, (bc)
      00042E 3C               [ 4]  820 	inc	a
      00042F 02               [ 7]  821 	ld	(bc), a
      000430                        822 00102$:
                                    823 ;main.c:187: if (camera.scroll_y > 223) //We need to reset the scroll_y to prevent it from hitching the screen, from overflow.
      000430 0A               [ 7]  824 	ld	a, (bc)
      000431 5F               [ 4]  825 	ld	e, a
      000432 3E DF            [ 7]  826 	ld	a, #0xdf
      000434 93               [ 4]  827 	sub	a, e
      000435 30 02            [12]  828 	jr	NC, 00104$
                                    829 ;main.c:189: camera.scroll_y = 0;
      000437 AF               [ 4]  830 	xor	a, a
      000438 02               [ 7]  831 	ld	(bc), a
      000439                        832 00104$:
                                    833 ;main.c:180: camera.rowoffset = 28 - (camera.scroll_y/8); //Get the position of the y scroll register in tiles.
      000439 0A               [ 7]  834 	ld	a, (bc)
                                    835 ;main.c:192: if (camera.scroll_y % 8 == 0 && camera.view_y < 24) //Time to update the row with tiles. Happens every 1 tile of scrolling. 8 x 8 pixels = 1 tile.
      00043A 4F               [ 4]  836 	ld	c, a
      00043B 06 00            [ 7]  837 	ld	b, #0x00
      00043D 79               [ 4]  838 	ld	a, c
      00043E E6 07            [ 7]  839 	and	a, #0x07
      000440 C2r06r05         [10]  840 	jp	NZ,00110$
      000443 2Ar02r00         [16]  841 	ld	hl, (#(_camera + 2) + 0)
      000446 11 18 80         [10]  842 	ld	de, #0x8018
      000449 29               [11]  843 	add	hl, hl
      00044A 3F               [ 4]  844 	ccf
      00044B CB 1C            [ 8]  845 	rr	h
      00044D CB 1D            [ 8]  846 	rr	l
      00044F ED 52            [15]  847 	sbc	hl, de
      000451 D2r06r05         [10]  848 	jp	NC, 00110$
                                    849 ;main.c:195: camera.rowoffset = (camera.scroll_y / 8) - 1;
      000454 CB 28            [ 8]  850 	sra	b
      000456 CB 19            [ 8]  851 	rr	c
      000458 CB 28            [ 8]  852 	sra	b
      00045A CB 19            [ 8]  853 	rr	c
      00045C CB 28            [ 8]  854 	sra	b
      00045E CB 19            [ 8]  855 	rr	c
      000460 0B               [ 6]  856 	dec	bc
      000461 ED 43r08r00      [20]  857 	ld	((_camera + 8)), bc
                                    858 ;main.c:197: unsigned char coloffset = camera.coloffset; //Save the last state of coloffset in a temp variable.
      000465 21r06r00         [10]  859 	ld	hl, #_camera + 6
      000468 4E               [ 7]  860 	ld	c, (hl)
                                    861 ;main.c:198: unsigned char xdex = 0; //We store the current x loop position, in order to subtract from the loop, to start at zero again when at last tile position.
      000469 DD 36 FC 00      [19]  862 	ld	-4 (ix), #0x00
                                    863 ;main.c:200: for (unsigned char x = 0; x < 32; x ++)
      00046D DD 36 FF 00      [19]  864 	ld	-1 (ix), #0x00
      000471                        865 00115$:
                                    866 ;main.c:182: if (camera.view_y < 24) //Prvent the scrolling from going past the height of the map. 24 tiles = 192 pixels
      000471 21r02r00         [10]  867 	ld	hl, #(_camera + 2)
      000474 7E               [ 7]  868 	ld	a, (hl)
      000475 DD 77 FD         [19]  869 	ld	-3 (ix), a
      000478 23               [ 6]  870 	inc	hl
      000479 7E               [ 7]  871 	ld	a, (hl)
      00047A DD 77 FE         [19]  872 	ld	-2 (ix), a
                                    873 ;main.c:200: for (unsigned char x = 0; x < 32; x ++)
      00047D DD 7E FF         [19]  874 	ld	a, -1 (ix)
      000480 D6 20            [ 7]  875 	sub	a, #0x20
      000482 30 77            [12]  876 	jr	NC, 00108$
                                    877 ;main.c:202: if (x >= 32 - coloffset && coloffset != 0)//When screen is offset, as the loop reaches the edge of the screen, we need to reset the loop so it begins at zero to finish off tiling.
      000484 59               [ 4]  878 	ld	e, c
      000485 16 00            [ 7]  879 	ld	d, #0x00
      000487 21 20 00         [10]  880 	ld	hl, #0x0020
      00048A BF               [ 4]  881 	cp	a, a
      00048B ED 52            [15]  882 	sbc	hl, de
      00048D DD 5E FF         [19]  883 	ld	e, -1 (ix)
      000490 16 00            [ 7]  884 	ld	d, #0x00
      000492 7B               [ 4]  885 	ld	a, e
      000493 95               [ 4]  886 	sub	a, l
      000494 7A               [ 4]  887 	ld	a, d
      000495 9C               [ 4]  888 	sbc	a, h
      000496 E2r9Br04         [10]  889 	jp	PO, 00191$
      000499 EE 80            [ 7]  890 	xor	a, #0x80
      00049B                        891 00191$:
      00049B FArAAr04         [10]  892 	jp	M, 00106$
      00049E 79               [ 4]  893 	ld	a, c
      00049F B7               [ 4]  894 	or	a, a
      0004A0 28 08            [12]  895 	jr	Z, 00106$
                                    896 ;main.c:204: coloffset = 0; //removes the offset from the equation. we need to start at zero.
      0004A2 0E 00            [ 7]  897 	ld	c, #0x00
                                    898 ;main.c:205: xdex = x; //store the x loop current index, to subtract it.
      0004A4 DD 7E FF         [19]  899 	ld	a, -1 (ix)
      0004A7 DD 77 FC         [19]  900 	ld	-4 (ix), a
      0004AA                        901 00106$:
                                    902 ;main.c:207: SMS_loadTileMap(coloffset + (x - xdex),camera.rowoffset,brawl_street_tilemap_bin + (camera.view_x + (x * 2)) + (((camera.view_y + 28) * 96) * 2),2);
      0004AA 2Ar00r00         [16]  903 	ld	hl, (#_camera + 0)
      0004AD EB               [ 4]  904 	ex	de, hl
      0004AE 29               [11]  905 	add	hl, hl
      0004AF EB               [ 4]  906 	ex	de, hl
      0004B0 19               [11]  907 	add	hl, de
      0004B1 EB               [ 4]  908 	ex	de, hl
      0004B2 21r00r00         [10]  909 	ld	hl, #_brawl_street_tilemap_bin
      0004B5 19               [11]  910 	add	hl, de
      0004B6 EB               [ 4]  911 	ex	de, hl
      0004B7 DD 7E FD         [19]  912 	ld	a, -3 (ix)
      0004BA C6 1C            [ 7]  913 	add	a, #0x1c
      0004BC 6F               [ 4]  914 	ld	l, a
                                    915 ;	spillPairReg hl
                                    916 ;	spillPairReg hl
      0004BD DD 7E FE         [19]  917 	ld	a, -2 (ix)
      0004C0 CE 00            [ 7]  918 	adc	a, #0x00
      0004C2 67               [ 4]  919 	ld	h, a
                                    920 ;	spillPairReg hl
                                    921 ;	spillPairReg hl
      0004C3 D5               [11]  922 	push	de
      0004C4 5D               [ 4]  923 	ld	e, l
      0004C5 54               [ 4]  924 	ld	d, h
      0004C6 29               [11]  925 	add	hl, hl
      0004C7 19               [11]  926 	add	hl, de
      0004C8 29               [11]  927 	add	hl, hl
      0004C9 29               [11]  928 	add	hl, hl
      0004CA 29               [11]  929 	add	hl, hl
      0004CB 29               [11]  930 	add	hl, hl
      0004CC 29               [11]  931 	add	hl, hl
      0004CD 29               [11]  932 	add	hl, hl
      0004CE D1               [10]  933 	pop	de
      0004CF 19               [11]  934 	add	hl, de
      0004D0 EB               [ 4]  935 	ex	de, hl
      0004D1 2Ar08r00         [16]  936 	ld	hl, (#(_camera + 8) + 0)
      0004D4 29               [11]  937 	add	hl, hl
      0004D5 29               [11]  938 	add	hl, hl
      0004D6 29               [11]  939 	add	hl, hl
      0004D7 29               [11]  940 	add	hl, hl
      0004D8 29               [11]  941 	add	hl, hl
      0004D9 DD 7E FF         [19]  942 	ld	a, -1 (ix)
      0004DC DD 96 FC         [19]  943 	sub	a, -4 (ix)
      0004DF 81               [ 4]  944 	add	a, c
      0004E0 06 00            [ 7]  945 	ld	b, #0x00
      0004E2 85               [ 4]  946 	add	a, l
      0004E3 6F               [ 4]  947 	ld	l, a
                                    948 ;	spillPairReg hl
                                    949 ;	spillPairReg hl
      0004E4 78               [ 4]  950 	ld	a, b
      0004E5 8C               [ 4]  951 	adc	a, h
      0004E6 67               [ 4]  952 	ld	h, a
                                    953 ;	spillPairReg hl
                                    954 ;	spillPairReg hl
      0004E7 29               [11]  955 	add	hl, hl
      0004E8 7C               [ 4]  956 	ld	a, h
      0004E9 F6 78            [ 7]  957 	or	a, #0x78
      0004EB 67               [ 4]  958 	ld	h, a
                                    959 ;	spillPairReg hl
                                    960 ;	spillPairReg hl
      0004EC C5               [11]  961 	push	bc
      0004ED 01 02 00         [10]  962 	ld	bc, #0x0002
      0004F0 C5               [11]  963 	push	bc
      0004F1 CDr00r00         [17]  964 	call	_SMS_VRAMmemcpy
      0004F4 C1               [10]  965 	pop	bc
                                    966 ;main.c:200: for (unsigned char x = 0; x < 32; x ++)
      0004F5 DD 34 FF         [23]  967 	inc	-1 (ix)
      0004F8 C3r71r04         [10]  968 	jp	00115$
      0004FB                        969 00108$:
                                    970 ;main.c:211: camera.view_y++; //Increase the view_y by 1.
      0004FB DD 4E FD         [19]  971 	ld	c, -3 (ix)
      0004FE DD 46 FE         [19]  972 	ld	b, -2 (ix)
      000501 03               [ 6]  973 	inc	bc
      000502 ED 43r02r00      [20]  974 	ld	((_camera + 2)), bc
      000506                        975 00110$:
                                    976 ;main.c:213: if (camera.rowoffset == 28) //Reset rowoffset because the nametable(the tilemap table in VRAM) only has 28 tiles in height (256 x 224. the 32 extra pixels in height is cropped in NTSC resolution..)
      000506 2Ar08r00         [16]  977 	ld	hl, (#(_camera + 8) + 0)
      000509 7D               [ 4]  978 	ld	a, l
      00050A D6 1C            [ 7]  979 	sub	a, #0x1c
      00050C B4               [ 4]  980 	or	a, h
      00050D 20 06            [12]  981 	jr	NZ, 00117$
                                    982 ;main.c:215: camera.rowoffset = 0;
      00050F 21 00 00         [10]  983 	ld	hl, #0x0000
      000512 22r08r00         [16]  984 	ld	((_camera + 8)), hl
      000515                        985 00117$:
                                    986 ;main.c:218: }
      000515 DD F9            [10]  987 	ld	sp, ix
      000517 DD E1            [14]  988 	pop	ix
      000519 C9               [10]  989 	ret
                                    990 ;main.c:222: void main(void)
                                    991 ;	---------------------------------
                                    992 ; Function main
                                    993 ; ---------------------------------
      00051A                        994 _main::
                                    995 ;main.c:225: SMS_displayOff();
      00051A 21 40 01         [10]  996 	ld	hl, #0x0140
      00051D CDr00r00         [17]  997 	call	_SMS_VDPturnOffFeature
                                    998 ;main.c:228: SMS_VRAMmemsetW(0, 0x0000, 16384);
      000520 21 00 40         [10]  999 	ld	hl, #0x4000
      000523 E5               [11] 1000 	push	hl
      000524 11 00 00         [10] 1001 	ld	de, #0x0000
      000527 65               [ 4] 1002 	ld	h, l
      000528 CDr00r00         [17] 1003 	call	_SMS_VRAMmemsetW
                                   1004 ;main.c:229: SMS_zeroBGPalette();
      00052B CDr00r00         [17] 1005 	call	_SMS_zeroBGPalette
                                   1006 ;main.c:230: SMS_zeroSpritePalette();
      00052E CDr00r00         [17] 1007 	call	_SMS_zeroSpritePalette
                                   1008 ;main.c:233: SMS_VDPturnOnFeature(VDPFEATURE_LEFTCOLBLANK);
      000531 21 20 00         [10] 1009 	ld	hl, #0x0020
      000534 CDr00r00         [17] 1010 	call	_SMS_VDPturnOnFeature
                                   1011 ;main.c:234: SMS_VDPturnOnFeature(VDPFEATURE_HIDEFIRSTCOL);
      000537 21 20 00         [10] 1012 	ld	hl, #0x0020
      00053A CDr00r00         [17] 1013 	call	_SMS_VDPturnOnFeature
                                   1014 ;main.c:237: SMS_mapROMBank(bg_pal_bin_bank);
      00053D 21 FF FF         [10] 1015 	ld	hl, #_ROM_bank_to_be_mapped_on_slot2
      000540 36 03            [10] 1016 	ld	(hl), #0x03
                                   1017 ;main.c:238: SMS_loadBGPalette(bg_pal_bin);
      000542 21r00r00         [10] 1018 	ld	hl, #_bg_pal_bin
      000545 CDr00r00         [17] 1019 	call	_SMS_loadBGPalette
                                   1020 ;main.c:239: SMS_loadSpritePalette(spr_pal_bin);
      000548 21r00r00         [10] 1021 	ld	hl, #_spr_pal_bin
      00054B CDr00r00         [17] 1022 	call	_SMS_loadSpritePalette
                                   1023 ;main.c:242: SMS_setBackdropColor(15);
      00054E 2E 0F            [ 7] 1024 	ld	l, #0x0f
                                   1025 ;	spillPairReg hl
                                   1026 ;	spillPairReg hl
      000550 CDr00r00         [17] 1027 	call	_SMS_setBackdropColor
                                   1028 ;main.c:245: SMS_loadPSGaidencompressedTiles(font_8x8_psgcompr,192);
      000553 11 00 58         [10] 1029 	ld	de, #0x5800
      000556 21r00r00         [10] 1030 	ld	hl, #_font_8x8_psgcompr
      000559 CDr00r00         [17] 1031 	call	_SMS_loadPSGaidencompressedTilesatAddr
                                   1032 ;main.c:246: SMS_configureTextRenderer(160);
      00055C 21 A0 00         [10] 1033 	ld	hl, #0x00a0
      00055F CDr00r00         [17] 1034 	call	_SMS_configureTextRenderer
                                   1035 ;main.c:250: SMS_mapROMBank(brawl_street_tiles_psgcompr_bank);
      000562 21 FF FF         [10] 1036 	ld	hl, #_ROM_bank_to_be_mapped_on_slot2
      000565 36 03            [10] 1037 	ld	(hl), #0x03
                                   1038 ;main.c:251: SMS_loadPSGaidencompressedTiles(brawl_street_tiles_psgcompr,0);
      000567 11 00 40         [10] 1039 	ld	de, #0x4000
      00056A 21r00r00         [10] 1040 	ld	hl, #_brawl_street_tiles_psgcompr
      00056D CDr00r00         [17] 1041 	call	_SMS_loadPSGaidencompressedTilesatAddr
                                   1042 ;main.c:255: init_camera();
      000570 CDr00r00         [17] 1043 	call	_init_camera
                                   1044 ;main.c:256: redraw_stage(); //Draw map at current view position.
      000573 CDr28r00         [17] 1045 	call	_redraw_stage
                                   1046 ;main.c:259: SMS_displayOn();
      000576 21 40 01         [10] 1047 	ld	hl, #0x0140
      000579 CDr00r00         [17] 1048 	call	_SMS_VDPturnOnFeature
      00057C                       1049 00110$:
                                   1050 ;main.c:266: if (SMS_getKeysHeld() & PORT_A_KEY_RIGHT)
      00057C CDr00r00         [17] 1051 	call	_SMS_getKeysHeld
      00057F CB 5B            [ 8] 1052 	bit	3, e
      000581 28 03            [12] 1053 	jr	Z, 00102$
                                   1054 ;main.c:269: cam_pan_right();
      000583 CDr6Ar00         [17] 1055 	call	_cam_pan_right
      000586                       1056 00102$:
                                   1057 ;main.c:271: if (SMS_getKeysHeld() & PORT_A_KEY_LEFT)
      000586 CDr00r00         [17] 1058 	call	_SMS_getKeysHeld
      000589 CB 53            [ 8] 1059 	bit	2, e
      00058B 28 03            [12] 1060 	jr	Z, 00104$
                                   1061 ;main.c:274: cam_pan_left();
      00058D CDrA9r01         [17] 1062 	call	_cam_pan_left
      000590                       1063 00104$:
                                   1064 ;main.c:276: if (SMS_getKeysHeld() & PORT_A_KEY_UP)
      000590 CDr00r00         [17] 1065 	call	_SMS_getKeysHeld
      000593 CB 43            [ 8] 1066 	bit	0, e
      000595 28 03            [12] 1067 	jr	Z, 00106$
                                   1068 ;main.c:278: cam_pan_up();
      000597 CDrCAr02         [17] 1069 	call	_cam_pan_up
      00059A                       1070 00106$:
                                   1071 ;main.c:280: if (SMS_getKeysHeld() & PORT_A_KEY_DOWN)
      00059A CDr00r00         [17] 1072 	call	_SMS_getKeysHeld
      00059D CB 4B            [ 8] 1073 	bit	1, e
      00059F 28 03            [12] 1074 	jr	Z, 00108$
                                   1075 ;main.c:282: cam_pan_down();
      0005A1 CDrF5r03         [17] 1076 	call	_cam_pan_down
      0005A4                       1077 00108$:
                                   1078 ;main.c:284: SMS_waitForVBlank();
      0005A4 CDr00r00         [17] 1079 	call	_SMS_waitForVBlank
                                   1080 ;main.c:286: SMS_setBGScrollX(camera.scroll_x);
      0005A7 21r04r00         [10] 1081 	ld	hl, #_camera + 4
      0005AA 6E               [ 7] 1082 	ld	l, (hl)
                                   1083 ;	spillPairReg hl
      0005AB CDr00r00         [17] 1084 	call	_SMS_setBGScrollX
                                   1085 ;main.c:287: SMS_setBGScrollY(camera.scroll_y);
      0005AE 21r05r00         [10] 1086 	ld	hl, #_camera + 5
      0005B1 6E               [ 7] 1087 	ld	l, (hl)
                                   1088 ;	spillPairReg hl
      0005B2 CDr00r00         [17] 1089 	call	_SMS_setBGScrollY
                                   1090 ;main.c:288: SMS_initSprites();
      0005B5 CDr00r00         [17] 1091 	call	_SMS_initSprites
                                   1092 ;main.c:290: SMS_copySpritestoSAT();
      0005B8 CDr00r00         [17] 1093 	call	_SMS_copySpritestoSAT
                                   1094 ;main.c:293: }
      0005BB 18 BF            [12] 1095 	jr	00110$
                                   1096 	.area _CODE
      0005BD                       1097 __str_0:
      0005BD 4F 72 61 6E 67 65 52  1098 	.ascii "OrangeRevolt"
             65 76 6F 6C 74
      0005C9 00                    1099 	.db 0x00
      0005CA                       1100 __str_1:
      0005CA 53 63 72 6F 6C 6C 69  1101 	.ascii "Scrolling"
             6E 67
      0005D3 00                    1102 	.db 0x00
      0005D4                       1103 __str_2:
      0005D4 38 20 77 61 79 20 73  1104 	.ascii "8 way smooth scrolling example."
             6D 6F 6F 74 68 20 73
             63 72 6F 6C 6C 69 6E
             67 20 65 78 61 6D 70
             6C 65 2E
      0005F3 00                    1105 	.db 0x00
                                   1106 	.area _INITIALIZER
                                   1107 	.area _CABS (ABS)
      007FF0                       1108 	.org 0x7FF0
      007FF0                       1109 ___SMS__SEGA_signature:
      007FF0 54                    1110 	.db #0x54	; 84	'T'
      007FF1 4D                    1111 	.db #0x4d	; 77	'M'
      007FF2 52                    1112 	.db #0x52	; 82	'R'
      007FF3 20                    1113 	.db #0x20	; 32
      007FF4 53                    1114 	.db #0x53	; 83	'S'
      007FF5 45                    1115 	.db #0x45	; 69	'E'
      007FF6 47                    1116 	.db #0x47	; 71	'G'
      007FF7 41                    1117 	.db #0x41	; 65	'A'
      007FF8 FF                    1118 	.db #0xff	; 255
      007FF9 FF                    1119 	.db #0xff	; 255
      007FFA FF                    1120 	.db #0xff	; 255
      007FFB FF                    1121 	.db #0xff	; 255
      007FFC 99                    1122 	.db #0x99	; 153
      007FFD 99                    1123 	.db #0x99	; 153
      007FFE 00                    1124 	.db #0x00	; 0
      007FFF 4C                    1125 	.db #0x4c	; 76	'L'
      007FD3                       1126 	.org 0x7FD3
      007FD3                       1127 ___SMS__SDSC_author:
      007FD3 4F 72 61 6E 67 65 52  1128 	.ascii "OrangeRevolt"
             65 76 6F 6C 74
      007FDF 00                    1129 	.db 0x00
      007FC9                       1130 	.org 0x7FC9
      007FC9                       1131 ___SMS__SDSC_name:
      007FC9 53 63 72 6F 6C 6C 69  1132 	.ascii "Scrolling"
             6E 67
      007FD2 00                    1133 	.db 0x00
      007FA9                       1134 	.org 0x7FA9
      007FA9                       1135 ___SMS__SDSC_descr:
      007FA9 38 20 77 61 79 20 73  1136 	.ascii "8 way smooth scrolling example."
             6D 6F 6F 74 68 20 73
             63 72 6F 6C 6C 69 6E
             67 20 65 78 61 6D 70
             6C 65 2E
      007FC8 00                    1137 	.db 0x00
      007FE0                       1138 	.org 0x7FE0
      007FE0                       1139 ___SMS__SDSC_signature:
      007FE0 53                    1140 	.db #0x53	; 83	'S'
      007FE1 44                    1141 	.db #0x44	; 68	'D'
      007FE2 53                    1142 	.db #0x53	; 83	'S'
      007FE3 43                    1143 	.db #0x43	; 67	'C'
      007FE4 01                    1144 	.db #0x01	; 1
      007FE5 00                    1145 	.db #0x00	; 0
      007FE6 00                    1146 	.db #0x00	; 0
      007FE7 00                    1147 	.db #0x00	; 0
      007FE8 00                    1148 	.db #0x00	; 0
      007FE9 00                    1149 	.db #0x00	; 0
      007FEA D3                    1150 	.db #0xd3	; 211
      007FEB 7F                    1151 	.db #0x7f	; 127
      007FEC C9                    1152 	.db #0xc9	; 201
      007FED 7F                    1153 	.db #0x7f	; 127
      007FEE A9                    1154 	.db #0xa9	; 169
      007FEF 7F                    1155 	.db #0x7f	; 127
